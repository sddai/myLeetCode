# 递归的核心思路
**所有递归的算法，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码，你要写递归算法，本质上就是要告诉每个节点需要做什么。**
# 一个例子对比迭代和递归的区别与联系
对于一个数组`arr = [1, 2, 3, 4, 5]`，分别使用for循环和递归方法依次打印每个元素。

1. for循环方法：
```python
for i in range(len(arr)):
    print(arr[i])
` ``

2. 递归法：
```python
def printArr(arr, i):
    if i == len(arr):   # base case
        return 
    print(arr[i])      # 打印arr[i]
    printArr(arr, i + 1) # 打印arr[i+1]及其后边的元素（递归调用自己）
```

## 分析：

在递归方法中，通过给函数增加了一个参数i，模拟了for循环的效果。（额外增加参数）

## 思考：

如果想倒序打印，怎么办？
答：只需要后序遍历，把print和递归调用调换顺序。

# 链表的递归实现

用递归去修改数据结构，递归函数必须有返回值并且返回值要被接收。

## 举例：删除链表最后一个节点
```python
# 例如：a -> x -> y -> None
def removeLast(node):
    if node.next == None:
        return None   # 删掉了y，y变成了None
    node.next = removeLast(node.next)  # x.next = None
    return node  # removeLast(x)会返回x本身，x前边的a调用函数，会返回x，所以前边的链接不会断
```

## 举例：删除链表中第i个节点（从0开始计数）
```python
# 例如：a -> b -> c -> d -> None
def remove(node, i):
    if i == 0:
        return node.next
    # 分析：a.next = remove(b, 0)，然后remove返回b.next = c
    node.next = remove(node.next, i - 1)
    return node
```

# 迭代法处理链表
## for循环反转链表
```python
# 反转以 a 为头结点的链表
ListNode reverse(ListNode a) {
    ListNode pre, cur, nxt;
    pre = null; cur = a; nxt = a;
    while (cur != null) {
        nxt = cur.next;    # next记录下一个集诶单的位置用于平移
        # 逐个结点反转
        cur.next = pre;    # 把cur和pre调转方向
        # 更新指针位置
        pre = cur;   # 这两句用于将两个指针向下平移
        cur = nxt;
    }
    # 返回反转后的头结点
    return pre;
}
```