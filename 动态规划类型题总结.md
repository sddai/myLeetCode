## 动态规划的特点
动态规划是一种最优化算法，所以是**求最值**的一类问题。
* 正确的「状态转移方程」（最关键）
* 判断「最优子结构」
* 「重叠子问题」
## 动态规划的核心：**穷举**
* 穷举需要递归
## 动态规划的通用技巧：
**数学归纳思想**
## 解题套路：
1. 明确“状态”：dp函数的参数，dp数组的索引
2. 明确“选择”：求最值的过程，做选择
3. 明确dp函数/数组的定义
4. 明确base case：if i == 0: ...
## dp问题的代码框架（递归）
```python
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result
```
## dp问题的代码框架（迭代）
```python
# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```
**设计算法，其实就是设计一个穷举，然后思考如何更高效地穷举。**
过程：暴力解——>备忘录——>自底向上
算法的过程就是根据**状态**决定如何做**选择**。

## 思考套路：
**对于最长递增子序列问题（或者一般的动态规划问题），通常都可以用「选或不选」和「枚举选哪个」来启发思考。**

## 关于暴力解：
**千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程。
只要写出暴力解，优化方法无非是用备忘录或者 DP table（dp数组），再无奥妙可言。**

# 一些思考：
计算机解决问题其实没有任何特殊的技巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。

# 关于动态规划dp数组的空间压缩
* 先考虑第零行
* 然后，这个dp[j]数组“**自我更新**”  

这个数组怎么自我更新呢？
例如：第一行是`[a, b, c, d, e]`

下一轮`a`变成`a'`，直接覆盖

`b'`依赖`a'`和`b`（左边和上边）

**现在考虑另一种情况（三个依赖，依赖左边、上边和左上角）**

这时如何自我更新？

按列数申请空间

例如第一行是`[a,  b,  c,  d,  e ]`

下一轮变成了`[a', b', c', d', e']`

下一轮`a`变成`a'`，

`a'`是第一个元素，没有左上角，直接更新

但是`a`被`a'` 覆盖掉了，而`a`在接下来更新`b`的时候会用到，所以要用一个变量把上一轮的`a`存下来，再更新成`a'`，（换句话说，更新`b'`需要用到`a`，`b`，`a'`三个变量，所以`a`的位置不能直接覆盖，而是应该把上一轮的数据留下来：`t = a; a = a'`，然后`t = b; b = b'`）

**第三种情况：当前值依赖左上、上、右上、左边**四个值

此时，需要用到两个数组，A和B

A用于记录上一轮的整行结果，B用来更新，更新之后用B更新A

也就是：
1. 更新A数组`A=[a, b, c, d, e]`
2. A记录了上一轮的整行情况，以此为依据更新B
3. 最后再重新更新A（A、B交替滚动），注意第一轮更新时A时下一行的值，接下来更新B是下一行的值

**下面考虑列数远远大于行数的情况：（此时，如果dp按j存储仍然浪费空间）**

答：此时dp按照i分配空间

**推广：如果当前值与上一行、上两行的值都有关系，怎么办？**

答：准备四个滚动数组，先得到前三行

## 空间压缩的常见类型：
1. 从左往右型问题（eg. 背包问题、硬币找零问题）
2. 范围尝试型问题（eg. 在LR边界拿硬币，回文问题）
3. 两个样本，一个做行一个做列，求指标型问题（eg. 最长公共子序列）
4. 无限制，人为找限制，分支限界型问题